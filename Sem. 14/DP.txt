Динамично програмиране и мемоизация.
Рекурсия:
Мем - рекурсивно решение, но с въведен "кеш".
ДП - Решение с попълване на таблица на стойностите започквайки от долу нагоре

Прости примери:

1. Числата на фибоначи
  -рек, мем, ДП.
  
  
2. Числата на каталан.
   Вход: 5  Изход: C_5 = 14
  -рек, мем, ДП.
 // 1, 1, 2, 5, 14, 42, 132 ... 
 
 //C_5 = C_1*C_4 + C_2*C_3+C_3*C_2+C_4*C_1
 
 Пример за задача, в която мем и дп не са нужни:
 Пресмятане на n! рекурсивно.
 
  5! = 5 * 4!
  4! = 4 * 3!
  
По-смислени задачи:


3. Дадена е матрица NxM с цели числа.
Търсим път от (0, 0) до (N-1, M-1). 
Пътят да е с максимална сума на клетките в мартицата.   
Позволени са само движения надолу и надясно.

Решение:

Рекурсивно: 
T == 0 & K == 0
matrix[0][0]

T == 0 
maxPathValue( (0,0) -> (T, K) ) = matrix[T][K] + maxPathValue(T,K-1);

K == 0
maxPathValue( (0,0) -> (T, K) )  = matrix[T][K] + maxPathValue(T-1,K)

T != 0 и  K!=0
maxPathValue( (0,0) -> (T, K) )=
matrix[T][K] + MAX (maxPathValue(T-1, K), maxPathValue(T,K-1))

ДП:
Двумерна таблица:
DP[i][j] - най-добрият път от (0,0) до (i,j)

DP[0][j] = DP[0][j-1] + matrix[0][j]
DP[i][0] = DP[i-1][0] + matrix[i][0]
DP[i][j] = max(DP[i-1][j], DP[i][j-1]) + matrix[i][j]

Резултатът се намира в:
DP[N-1][M-1]

Възстановяване -> Какъв е пътят?	
Гледаме DP. На клетката (i,j) сме дошли от по-голямото от matrix[i-1][j], mаtrix[i][j-1].

(Потенциална оптимизация: Да пазим само последните 2 колони)


4. Даден е масив с цели числа и цяло число К.
Съществуват ли елементи на мисива, чиято сума е K. Не може да повтаряме елементи.

//Subset sum   М = {1,2,3,4}. Същ ли подмножетство на М със сума K. 

// [1, 5, 9, 4, 7]   K = 15.

Sum(arr,K) - същ... чиято сума е K

Sum( [1,5,9,4,7], 15) = Sum([1,5,9,4], 15) ИЛИ Sum([1,5,9,4], 8)

Sum([1,5,9,4], 15) = Sum([1,5,9], 15) ИЛИ Sum([1,5,9], 11)


Sum([...,5,4,9], 10) = 

Рекурсивно:
Sum(arr[0...n-1], K) = Sum(arr[0...n-2], K) или Sum(arr[0...n-2], K - arr[n-1])

Д.П.
DP[i][j] = Може ли да се направи сума j с първите i елемента от масива
DP[0][0] = Истина

j != 0
DP[0][j] = Лъжа
DP[i][0] = Истина

DP[i][j] = DP[i-1][j] или DP[i-1][j - arr[i-1]]]

Резултатът се намира в клетката DP[n(големината на масива)] [Sum]

(Потенциална оптимизация: Да пазим само последните 2 реда)

Възстановяване:
Ако DP[i-1][j] е истина, то НЕ включваме в множеството елементът на индекс j.
Ако е лъжа, го включваме и разглеждаме за предишния елемент на на DP[i-1][j - arr[i-1]]

Задача 5:
Даден е масив:
[4, 6, 3, 2, 8, 10, 5] .
Търсим дължината на най-дългата растящя подредица на масива.

longestIncSubseq(arr, i) - дължината на най-дългата растяща подредица на масива arr, 
която приключва с елемента на индекс i.

Отговор: max { longestIncSubseq(arr, 0), longestIncSubseq(arr, 1), ... longestIncSubseq(arr, n-1)}

Рекурсивно:
longestIncSubseq(arr, 0) = 1
longestIncSubseq(arr, k) = 1 + max{  longestIncSubseq(arr,j) | j < 6 && arr[j] < arr[k] }

DP:
DP[i]-дължината на най-дългата растяща подредица на масива arr, която приключва с елемента на индекс i.
DP[0] = 1
DP[i] = 1 + max{DP[j] | 1<=j<i и arr[j] < аrr[i] }

Резултатът го пазим в най-големия елемент на масива DP.

0(n^2)

!!DP не винаги дава най-доброто решение!!
Съществува алгоритъм n*log(n). Използва се сортиране чрез пасианс.

Задача 6:
Най-къси пътища между всички двойки върхове в графа.
//Floyd-warshal;

k- междинен път!
DP[i][j] = най-късият път от i до j.
Най-късият път е изграден от най-къси пътищя!
Това не е изпълнено за най-дългите пътища!

Задача 7:
Даден е ДАГ. Начален връх start и краен end. Брой пътища от start до end.?

Топологично сортиране.

pathCount(X,Y) - брой пътища от X до Y.

X = Y
pathCount(X,Y) = 1

X!=Y
pathCount(X,Y) = sum (pathCount(X,Z) | Z е предшествиник на Y)

DP[i] - брой пътища от x до i. 

DP[x] = 1.
DP[i] = sum DP[j] j е преди i в топопологичната сортировка и има ребро j -> i
Резултат: DP[Y]

